{
  "hash": "13dcae7fa14039bb53d8364b5adb87ff",
  "result": {
    "engine": "jupyter",
    "markdown": "# 05_sql_sqlite.qmd\n\n---\ntitle: \"05 — SQL & SQLite (Python)\"\nformat: html\nexecute:\n  echo: true\n---\n\nIntroduction — This page shows a small Python script that creates a local SQLite database, writes two tables from pandas DataFrames (`features` and `weekday_meta`), runs a JOIN query using SQL, and prints the result. The follow-up shell commands show how to run the script. Explanations below focus on the SQLite usage from the Python code and the example SQL query.\n\n::: {#2e3002e9 .cell execution_count=1}\n``` {.python .cell-code}\nfrom pathlib import Path\nimport sqlite3\nimport pandas as pd\n\nPath(\"db\").mkdir(parents=True, exist_ok=True)\ncon = sqlite3.connect(\"db/synth.db\")\ntry:\n    df = pd.read_csv(\"data/processed/synth_features.csv\")\n    if \"weekday\" in df.columns:\n        df[\"weekday\"] = df[\"weekday\"].astype(int)\n    df.to_sql(\"features\", con, if_exists=\"replace\", index=False)\n\n    meta = pd.DataFrame({\n        \"weekday\": [1,2,3,4,5,6,7],\n        \"weekday_name\": [\"Mon\",\"Tue\",\"Wed\",\"Thu\",\"Fri\",\"Sat\",\"Sun\"]\n    })\n    meta.to_sql(\"weekday_meta\", con, if_exists=\"replace\", index=False)\n\n    q = \"\"\"\n    SELECT f.date, f.price, f.volume, f.log_return, f.sma_5, m.weekday_name\n    FROM features f JOIN weekday_meta m USING(weekday)\n    ORDER BY date LIMIT 10;\n    \"\"\"\n    print(pd.read_sql(q, con))\nfinally:\n    con.close()\n```\n\n::: {.cell-output .cell-output-stdout}\n```\n         date     price  volume  log_return      sma_5 weekday_name\n0  2022-01-01  100.4967     748    0.000000  100.49670          Sat\n1  2022-01-02  100.3584     417   -0.001377  100.42755          Sun\n2  2022-01-03  101.0061     776    0.006433  100.62040          Mon\n3  2022-01-04  102.5292     324    0.014967  101.09760          Tue\n4  2022-01-05  102.2950     918   -0.002287  101.33708          Wed\n5  2022-01-06  102.0609     333   -0.002291  101.64992          Thu\n6  2022-01-07  103.6401     783    0.015355  102.30626          Fri\n7  2022-01-08  104.4075     763    0.007377  102.98654          Sat\n8  2022-01-09  103.9381     926   -0.004506  103.26832          Sun\n9  2022-01-10  104.4806     473    0.005206  103.70544          Mon\n```\n:::\n:::\n\n\nThe Python code and SQLite explanations:\n\n- `sqlite3.connect(\"db/synth.db\")`  \n  Opens (or creates) a local SQLite database file at `db/synth.db`. The returned connection `con` is used for all subsequent SQL operations.\n\n- `df = pd.read_csv(\"data/processed/synth_features.csv\")` and `df.to_sql(\"features\", con, if_exists=\"replace\", index=False)`  \n  Loads the processed CSV into a pandas DataFrame and writes it to the SQLite database as a table named `features`. `if_exists=\"replace\"` overwrites any existing table with the same name; `index=False` prevents pandas from adding the DataFrame index as a separate column.\n\n- `df[\"weekday\"] = df[\"weekday\"].astype(int)`  \n  Ensures the `weekday` column uses an integer type compatible with SQL joins and the `weekday_meta` table.\n\n- Creating the `weekday_meta` DataFrame and writing it to SQL (`weekday_meta`)  \n  This small lookup table provides a human-readable `weekday_name` for join demonstrations. Storing reference/metadata tables in the same database is a common pattern for self-contained examples.\n\n- The SQL query string `q`  \n  The query selects date, price, volume, log return, 5-day simple moving average (`sma_5`), and the weekday name by joining `features` (`f`) with `weekday_meta` (`m`) using the `weekday` column. `USING(weekday)` is a concise SQL shorthand that matches the column in both tables; it is equivalent to `ON f.weekday = m.weekday`. `ORDER BY date LIMIT 10` sorts results by date and returns only the first ten rows — useful for quick previews.\n\n- `pd.read_sql(q, con)` and `print(...)`  \n  Executes the SQL query against the SQLite connection and returns the result as a pandas DataFrame, which is then printed to stdout. Using `pandas.read_sql` is convenient for moving data between SQL and pandas for analysis or display.\n\n- `finally: con.close()`  \n  Ensures the SQLite connection is closed regardless of success or failure, releasing file handles and flushing changes.\n\n```{bash}\nset -euo pipefail\npython3 scripts/make_sqlite.py\n```\n\nShell-run explanations:\n\n- `set -euo pipefail`  \n  A shell safety idiom that makes scripts fail-fast: `-e` exits on any non-zero command status, `-u` treats unset variables as errors, and `-o pipefail` causes a pipeline to fail if any component fails. While not SQLite-specific, it helps ensure the Python script's failures are propagated to the shell.\n\n- `python3 scripts/make_sqlite.py`  \n  Runs the Python script that creates/populates `db/synth.db` and executes the example SQL query. After running, check `db/synth.db` with SQLite tools (for example `sqlite3 db/synth.db` or GUI clients) to inspect the `features` and `weekday_meta` tables and to run ad-hoc queries.\n\n",
    "supporting": [
      "05_sql_sqlite_files"
    ],
    "filters": [],
    "includes": {}
  }
}