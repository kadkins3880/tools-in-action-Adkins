# 09_pytorch_miniloop.qmd
---
title: "09 — PyTorch Minimal Training Loop"
format: html
execute:
  echo: true
---

Introduction — Minimal example showing how to implement a small supervised training loop in PyTorch. The snippet covers dataset creation, a tiny GRU-based model, device selection (CPU/GPU), optimizer and loss setup, and the standard training loop (forward, backward, gradient clipping, step). Explanations below describe the PyTorch-specific components and the role each plays in training.

```{python}
#| eval: false
# Minimal PyTorch example (runs on CPU if CUDA unavailable)
import torch
import torch.nn as nn
import numpy as np

torch.manual_seed(0)
np.random.seed(0)

T, F, N = 16, 3, 512
X = np.random.normal(0, 0.5, size=(N, T, F)).astype("float32")
w = np.random.normal(0, 0.2, size=(F,)).astype("float32")
y = (X[:, -1, :] @ w + np.random.normal(0, 0.1, size=(N,))).astype("float32")

ds = torch.utils.data.TensorDataset(torch.from_numpy(X), torch.from_numpy(y))
dl = torch.utils.data.DataLoader(ds, batch_size=64, shuffle=True)

class SmallGRU(nn.Module):
    def __init__(self, F, H=32):
        super().__init__()
        self.gru = nn.GRU(F, H, batch_first=True)
        self.head = nn.Linear(H, 1)
    def forward(self, x):
        _, h = self.gru(x)
        return self.head(h[-1]).squeeze(-1)

device = torch.device("cuda" if torch.cuda.is_available() else "cpu")
net = SmallGRU(F).to(device)
opt = torch.optim.AdamW(net.parameters(), lr=3e-3)
loss_fn = nn.L1Loss()

for ep in range(1, 11):
    net.train()
    tot = 0.0
    for xb, yb in dl:
        xb, yb = xb.to(device), yb.to(device)
        opt.zero_grad(set_to_none=True)
        yhat = net(xb)
        loss = loss_fn(yhat, yb)
        loss.backward()
        nn.utils.clip_grad_norm_(net.parameters(), 1.0)
        opt.step()
        tot += loss.item() * xb.size(0)
    print(f"epoch {ep:02d} | train_mae={tot/len(ds):.6f}")
```

Explanation for the above code:

- `torch.manual_seed(0)` and `np.random.seed(0)`  
  Set deterministic seeds for PyTorch and NumPy random generators to make the example reproducible during development and demos. Full determinism across platforms requires additional PyTorch flags and may still vary by backend.

- Data creation and `TensorDataset` / `DataLoader`  
  The example synthesizes features `X` and targets `y` with NumPy, converts them to PyTorch tensors, and wraps them in a `TensorDataset`. `DataLoader` provides minibatch iteration (`batch_size=64`) and shuffling (`shuffle=True`), which is essential for stochastic optimization.

- `class SmallGRU(nn.Module):`  
  Defines a compact model with a single GRU layer and a linear head. `nn.GRU(F, H, batch_first=True)` processes sequences with `F` features per time step and returns a hidden state of size `H`. The model's `forward` returns a single scalar per sample by taking the final hidden state (`h[-1]`) and applying `self.head`.

- `device = torch.device("cuda" if torch.cuda.is_available() else "cpu")` and `.to(device)`  
  Selects GPU if available; otherwise uses CPU. Moving the model and tensors to the same device is required for computation. This pattern makes the script portable across machines with and without CUDA.

- `opt = torch.optim.AdamW(net.parameters(), lr=3e-3)`  
  Uses the AdamW optimizer (Adam with decoupled weight decay) for parameter updates. AdamW is a sensible default for many models; learning rate and optimizer choice depend on the task.

- `loss_fn = nn.L1Loss()`  
  L1 loss computes mean absolute error (MAE) between predictions and targets. It is robust to outliers compared to squared losses and is a common choice for regression tasks where MAE is a meaningful metric.

- Training loop structure:
  - `net.train()` sets the module to training mode (affects layers like dropout or batch norm).
  - For each batch: move inputs/targets to `device` with `.to(device)`.
  - `opt.zero_grad(set_to_none=True)` clears gradients; `set_to_none=True` can be marginally faster and uses slightly less memory.
  - `yhat = net(xb)` performs the forward pass.
  - `loss = loss_fn(yhat, yb)` computes the batch loss.
  - `loss.backward()` computes gradients via backpropagation.
  - `nn.utils.clip_grad_norm_(net.parameters(), 1.0)` applies gradient clipping by global norm to avoid exploding gradients and stabilize training.
  - `opt.step()` updates parameters using computed gradients.
  - `tot += loss.item() * xb.size(0)` accumulates the sum of per-example losses to compute epoch MAE.

- Epoch reporting: `tot/len(ds)`  
  After iterating batches, dividing the accumulated (sum) loss by dataset size yields the mean absolute error across the epoch. Printing this each epoch provides a simple training progress metric.

- Portability and small-scale notes:
  - The example runs fine on CPU for demonstration and on GPU if available. For real training with larger models or data, prefer proper device-aware data loading, mixed precision, and more robust reproducibility settings.
  - For deterministic behavior across runs and platforms, additional configuration is required (e.g., `torch.use_deterministic_algorithms(True)`), but this can reduce performance or rely on backend support.